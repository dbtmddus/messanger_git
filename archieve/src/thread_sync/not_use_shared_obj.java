package thread_sync;

import java.util.concurrent.locks.ReentrantLock;

class thread_extends extends Thread{
	static private ReentrantLock locker = new ReentrantLock();

	private int iden_n=0;
	private static int n=0;

	public thread_extends(int _iden_n){
		iden_n= _iden_n;
	}	

	@Override
	public void run(){
		locker.lock();
		f();
		locker.unlock();
	}

	public void f(){	//이 경우, class 자체를 혼자 독점하므로 이런 ㅓ방법은 비추천 되는듯(locker가 나음)
		//locker.lock();
		for(int i=0; i<100; i++){
			System.out.print(iden_n+"aaaaaaaaaaaaaaaaaaaaaaaaaa");			
			System.out.println(iden_n+"b");
			System.out.println(i);	
		}
		//locker.unlock();
	}
}


public class not_use_shared_obj {
	static private ReentrantLock locker = new ReentrantLock();

	public static void main(String[] args) throws InterruptedException {
		thread_extends t_extends1 = new thread_extends(1);	//이 자체가 이미 thread 생성임.
		thread_extends t_extends2 = new thread_extends(2);
				
		//locker.lock();	//이건 안됨. thread가 있는 class에서 써야하는듯
		t_extends1.start();
		//locker.unlock();
		t_extends2.start();		
	}
}
